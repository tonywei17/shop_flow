# DEVLOG - 2025-12-03

## 今日の開発トピック

- ロール管理における「機能権限（機能アクセス権）」のUI/データ構造の実装
- サイドバー（ナビゲーション）のロールベース表示制御
- ダッシュボード配下ページのルートレベルアクセス制御（機能単位のガード）
- admin アカウントのスーパーユーザー化

## 1. ロールの機能権限（feature_permissions）の永続化

### 1-1. DB/型定義の拡張

- 対象: `packages/db/src/roles.ts`
- 変更内容:
  - `RoleRecord` に `feature_permissions: string[] | null` を追加
  - `CreateRoleInput` / `UpdateRoleInput` に `feature_permissions?: string[] | null` を追加
  - `listRoles` の `select` に `feature_permissions` を含めるように変更
  - `createRole` / `updateRole` の payload に `feature_permissions` を追加し、Supabase の `roles` テーブルに読み書きできるようにした

> DB 側の前提:
>
> ```sql
> ALTER TABLE public.roles
> ADD COLUMN feature_permissions text[];
> ```
>
> を実行しておくこと。

### 1-2. API/バリデーション層

- 対象: `apps/web/src/lib/validation/roles.ts`
  - `roleCreateSchema` に `feature_permissions: z.array(z.string()).optional()` を追加
- 対象: `apps/web/src/app/api/internal/roles/route.ts`
  - 受信した JSON から `feature_permissions` を取り出し、`createRoleService` / `updateRoleService` に引き渡すように変更

これにより、フロントエンドから送られた機能権限の配列 (`string[]` / nav の href) が DB に保存・更新されるようになった。

## 2. ロール編集UIと機能権限ツリー

- 対象: `apps/web/src/app/(dashboard)/roles/roles-client.tsx`
- 変更ポイント:
  - 機能権限ツリーで選択した `selectedFeatures: string[]` を `feature_permissions` として API に送信する実装を維持しつつ、編集モード時に DB からの値を反映するようにした。
  - `handleOpenCreate`:
    - 新規作成時は `ALL_FEATURE_IDS`（全機能）を初期値としてセット。
  - `handleOpenEdit`:
    - `role.feature_permissions` が配列であれば、それを元に `selectedFeatures` を初期化。
    - 配列が空の場合は互換性のため `ALL_FEATURE_IDS` を fallback として使用（初期導入段階の UX を優先）。

この結果、今後ロールに対して機能権限を設定すると、再編集時にその設定が UI に正しく反映されるようになった。

## 3. サイドバーのロールベース表示制御

### 3-1. Sidebar コンポーネントの拡張

- 対象: `apps/web/src/components/dashboard/sidebar.tsx`
- 変更点:
  - `SidebarProps` に `allowedFeatureIds?: string[]` を追加。
  - `allowedFeatureIds` が `undefined` の場合は従来どおり全ての `navSections` を表示。
  - `allowedFeatureIds` が配列（空配列を含む）の場合は、nav の `href` を正規化した上で `allowedFeatureIds` に含まれるものだけを表示するようにした。

これにより、「このロールは `/members` と `/roles` だけ許可」のようなホワイトリスト型のメニュー表示が可能になった。

### 3-2. Dashboard Layout での allowedFeatureIds 計算

- 対象: `apps/web/src/app/(dashboard)/layout.tsx`
- 処理の流れ:
  1. `cookies()` から `admin_account_id` を取得。
  2. `admin_accounts` テーブルから該当レコードを取得し、`role_code` と `account_id` を参照。
  3. ロールコードがあれば `roles` テーブルから `feature_permissions` を取得。
  4. `navItems` に存在する href のみをフィルタした `allowedFeatureIds` を組み立て、`Sidebar` と `FeatureGuard` に渡す。

- 特別ルール:
  - `account_id === "admin"`、または `process.env.ADMIN_LOGIN_ID` と `admin_account_id` が一致する場合は「スーパーユーザー」とみなし、`allowedFeatureIds = undefined` としてメニュー/アクセス制御をスキップ（全機能アクセス許可）。
  - それ以外で `role_code` が空の場合は `allowedFeatureIds = []` とし、「何もアクセスできない」状態とする。

## 4. ルートレベルのアクセス制御（FeatureGuard）

### 4-1. FeatureGuard コンポーネント

- 新規ファイル: `apps/web/src/components/dashboard/feature-guard.tsx`
- 役割:
  - 現在の `pathname` と `navItems` から「この URL がどの機能（nav の href）に対応するか」を解決。
    - 例: `/members/123` → `/members` をその機能IDとみなす。
  - `allowedFeatureIds` が `undefined` の場合はガードを無効化（互換性モード）。
  - `allowedFeatureIds` が配列の場合は、その中に機能IDが含まれているかどうかでアクセス可否を判定し、含まれていない場合は 403 風メッセージを表示。

### 4-2. Layout への組み込み

- `DashboardLayout` の `main` 内で、子要素を `FeatureGuard` で wrap:

  ```tsx
  <main ...>
    <FeatureGuard allowedFeatureIds={allowedFeatureIds}>
      {children}
    </FeatureGuard>
  </main>
  ```

- これにより、(dashboard) 配下の全ページについて:
  - 該当ロールにその機能の権限が無い場合は中身がレンダリングされず、代わりに
    - 「この画面へのアクセス権限がありません。」という UI メッセージを表示。

## 5. admin アカウントのスーパーユーザー化

- 要件: `admin` アカウントは原則すべての機能にアクセスできる「スーパー管理者」とする。
- 実装: `DashboardLayout` 内での allowedFeatureIds 計算時に、以下の条件を追加:
  - `admin_accounts.account_id === "admin"` の場合、`isSuperAdmin = true`。
  - あるいは `process.env.ADMIN_LOGIN_ID` と `admin_account_id` cookie が一致する場合もスーパー管理者扱い。
- `isSuperAdmin === true` の場合:
  - `allowedFeatureIds = undefined` として、メニュー/画面アクセスのフィルタリングをスキップ。

## 6. コードヘルスチェック

- 実行コマンド:

  ```bash
  pnpm lint
  ```

- 結果:
  - 全パッケージの lint 成功。
  - `baseline-browser-mapping` のバージョンが 2ヶ月以上更新されていない旨の warning のみ（現時点では致命的ではないため、後日対応候補とする）。

## 7. 今後の TODO / 検討事項

- ルートレベルガードを HTTP ステータスレベル（例: 403 レスポンス or リダイレクト）まで拡張するかどうかの検討。
- Supabase schema を正式に `supabase/migrations` 以下に落とし込み、`roles.feature_permissions` を含めた形でバージョン管理する。
- API ルート（`/api/internal/...`）に対しても、ロールベースのアクセス制御を導入するかどうかの検討（現状は UI レイヤ中心の制御）。
